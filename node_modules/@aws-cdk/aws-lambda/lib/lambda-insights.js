"use strict";
var _a;
Object.defineProperty(exports, "__esModule", { value: true });
exports.LambdaInsightsVersion = void 0;
const JSII_RTTI_SYMBOL_1 = Symbol.for("jsii.rtti");
const core_1 = require("@aws-cdk/core");
const region_info_1 = require("@aws-cdk/region-info");
const architecture_1 = require("./architecture");
// This is the name of the mapping that will be added to the CloudFormation template, if a stack is region agnostic
const DEFAULT_MAPPING_PREFIX = 'LambdaInsightsVersions';
// To add new versions, update fact-tables.ts `CLOUDWATCH_LAMBDA_INSIGHTS_ARNS` and create a new `public static readonly VERSION_A_B_C_D`
/**
 * Version of CloudWatch Lambda Insights.
 *
 * @stability stable
 */
class LambdaInsightsVersion {
    constructor() {
        /**
         * The arn of the Lambda Insights extension.
         *
         * @stability stable
         */
        this.layerVersionArn = '';
    }
    /**
     * Use the insights extension associated with the provided ARN.
     *
     * Make sure the ARN is associated
     * with same region as your function
     *
     * @see https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/Lambda-Insights-extension-versions.html
     * @stability stable
     */
    static fromInsightVersionArn(arn) {
        class InsightsArn extends LambdaInsightsVersion {
            constructor() {
                super(...arguments);
                this.layerVersionArn = arn;
            }
            _bind(_scope, _function) {
                return { arn };
            }
        }
        return new InsightsArn();
    }
    // Use the verison to build the object. Not meant to be called by the user -- user should use e.g. VERSION_1_0_54_0
    static fromInsightsVersion(insightsVersion) {
        class InsightsVersion extends LambdaInsightsVersion {
            constructor() {
                super(...arguments);
                this.layerVersionArn = core_1.Lazy.uncachedString({
                    produce: (context) => getVersionArn(context, insightsVersion),
                });
            }
            _bind(_scope, _function) {
                var _b, _c;
                const arch = (_c = (_b = _function.architecture) === null || _b === void 0 ? void 0 : _b.name) !== null && _c !== void 0 ? _c : architecture_1.Architecture.X86_64.name;
                // Check if insights version is valid. This should only happen if one of the public static readonly versions are set incorrectly
                // or if the version is not available for the Lambda Architecture
                const versionExists = region_info_1.RegionInfo.regions.some(regionInfo => regionInfo.cloudwatchLambdaInsightsArn(insightsVersion, arch));
                if (!versionExists) {
                    throw new Error(`Insights version ${insightsVersion} does not exist.`);
                }
                return {
                    arn: core_1.Lazy.uncachedString({
                        produce: (context) => getVersionArn(context, insightsVersion, arch),
                    }),
                };
            }
        }
        return new InsightsVersion();
    }
}
exports.LambdaInsightsVersion = LambdaInsightsVersion;
_a = JSII_RTTI_SYMBOL_1;
LambdaInsightsVersion[_a] = { fqn: "@aws-cdk/aws-lambda.LambdaInsightsVersion", version: "1.136.0" };
/**
 * Version 1.0.54.0.
 *
 * @stability stable
 */
LambdaInsightsVersion.VERSION_1_0_54_0 = LambdaInsightsVersion.fromInsightsVersion('1.0.54.0');
/**
 * Version 1.0.86.0.
 *
 * @stability stable
 */
LambdaInsightsVersion.VERSION_1_0_86_0 = LambdaInsightsVersion.fromInsightsVersion('1.0.86.0');
/**
 * Version 1.0.89.0.
 *
 * @stability stable
 */
LambdaInsightsVersion.VERSION_1_0_89_0 = LambdaInsightsVersion.fromInsightsVersion('1.0.89.0');
/**
 * Version 1.0.98.0.
 *
 * @stability stable
 */
LambdaInsightsVersion.VERSION_1_0_98_0 = LambdaInsightsVersion.fromInsightsVersion('1.0.98.0');
/**
 * Version 1.0.119.0.
 *
 * @stability stable
 */
LambdaInsightsVersion.VERSION_1_0_119_0 = LambdaInsightsVersion.fromInsightsVersion('1.0.119.0');
/**
 * Function to retrieve the correct Lambda Insights ARN from RegionInfo,
 * or create a mapping to look it up at stack deployment time.
 *
 * This function is run on CDK synthesis.
 */
function getVersionArn(context, insightsVersion, architecture) {
    const scopeStack = core_1.Stack.of(context.scope);
    const region = scopeStack.region;
    const arch = architecture !== null && architecture !== void 0 ? architecture : architecture_1.Architecture.X86_64.name;
    // Region is defined, look up the arn, or throw an error if the version isn't supported by a region
    if (region !== undefined && !core_1.Token.isUnresolved(region)) {
        const arn = region_info_1.RegionInfo.get(region).cloudwatchLambdaInsightsArn(insightsVersion, arch);
        if (arn === undefined) {
            throw new Error(`Insights version ${insightsVersion} is not supported in region ${region}`);
        }
        return arn;
    }
    // Otherwise, need to add a mapping to be looked up at deployment time
    /**
     * See this for the context as to why the mappings are the way they are
     * https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/mappings-section-structure.html
     *
     * Mappings have to have a structure like this, and no functions can be used inside them:
     * <Alphanumeric only>
     * - <Can be non-alphanumeric>
     * -- { <alphanumeric>: "value1"},
     * -- { <alphanumeric>: "value2"}
     *
     * So we cannot have an otherwise ideal mapping like this, because '1.0.98.0' is non-alphanumeric:
     * LambdaInsightsVersions
     * - us-east-1
     * -- {'1.0.98.0': 'arn1'},
     * -- {'1.0.89.0': 'arn2'}
     *
     * To get around this limitation, this is the mapping structure:
     * LambdaInsightsVersions10980 // for version 1.0.98.0
     * - us-east-1
     * -- {'arn': 'arn1'},
     * - us-east-2
     * -- {'arn': 'arn2'}
     * LambdaInsightsVersions10890 // a separate mapping version 1.0.89.0
     * - us-east-1
     * -- {'arn': 'arn3'},
     * - us-east-2
     * -- {'arn': 'arn4'}
     * LambdaInsightsVersions101190arm64 // a separate mapping version 1.0.119.0 arm64
     * - us-east-1
     * -- {'arn': 'arn3'},
     * - us-east-2
     * -- {'arn': 'arn4'}
     */
    let mapName = DEFAULT_MAPPING_PREFIX + insightsVersion.split('.').join('');
    // if the architecture is arm64 then append that to the end of the name
    // this is so that we can have a separate mapping for x86 vs arm in scenarios
    // where we have Lambda functions with both architectures in the same stack
    if (arch === architecture_1.Architecture.ARM_64.name) {
        mapName += arch;
    }
    const mapping = {};
    const region2arns = region_info_1.RegionInfo.regionMap(region_info_1.FactName.cloudwatchLambdaInsightsVersion(insightsVersion, arch));
    for (const [reg, arn] of Object.entries(region2arns)) {
        mapping[reg] = { arn };
    }
    // Only create a given mapping once. If another version of insights is used elsewhere, that mapping will also exist
    if (!scopeStack.node.tryFindChild(mapName)) {
        // need to call findInMap here if we are going to set lazy=true, otherwise
        // we get the informLazyUse info message
        const map = new core_1.CfnMapping(scopeStack, mapName, { mapping, lazy: true });
        return map.findInMap(core_1.Aws.REGION, 'arn');
    }
    // The ARN will be looked up at deployment time from the mapping we created
    return core_1.Fn.findInMap(mapName, core_1.Aws.REGION, 'arn');
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibGFtYmRhLWluc2lnaHRzLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsibGFtYmRhLWluc2lnaHRzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7O0FBQUEsd0NBQXlGO0FBQ3pGLHNEQUE0RDtBQUU1RCxpREFBOEM7QUFJOUMsbUhBQW1IO0FBQ25ILE1BQU0sc0JBQXNCLEdBQUcsd0JBQXdCLENBQUM7QUFZeEQseUlBQXlJOzs7Ozs7QUFHekksTUFBc0IscUJBQXFCO0lBQTNDOzs7Ozs7UUF1RGtCLG9CQUFlLEdBQVcsRUFBRSxDQUFDO0tBUTlDOzs7Ozs7Ozs7O0lBN0NRLE1BQU0sQ0FBQyxxQkFBcUIsQ0FBQyxHQUFXO1FBQzdDLE1BQU0sV0FBWSxTQUFRLHFCQUFxQjtZQUEvQzs7Z0JBQ2tCLG9CQUFlLEdBQUcsR0FBRyxDQUFDO1lBSXhDLENBQUM7WUFIUSxLQUFLLENBQUMsTUFBaUIsRUFBRSxTQUFvQjtnQkFDbEQsT0FBTyxFQUFFLEdBQUcsRUFBRSxDQUFDO1lBQ2pCLENBQUM7U0FDRjtRQUNELE9BQU8sSUFBSSxXQUFXLEVBQUUsQ0FBQztLQUMxQjtJQUVELG1IQUFtSDtJQUMzRyxNQUFNLENBQUMsbUJBQW1CLENBQUMsZUFBdUI7UUFFeEQsTUFBTSxlQUFnQixTQUFRLHFCQUFxQjtZQUFuRDs7Z0JBQ2tCLG9CQUFlLEdBQUcsV0FBSSxDQUFDLGNBQWMsQ0FBQztvQkFDcEQsT0FBTyxFQUFFLENBQUMsT0FBTyxFQUFFLEVBQUUsQ0FBQyxhQUFhLENBQUMsT0FBTyxFQUFFLGVBQWUsQ0FBQztpQkFDOUQsQ0FBQyxDQUFDO1lBZ0JMLENBQUM7WUFkUSxLQUFLLENBQUMsTUFBaUIsRUFBRSxTQUFvQjs7Z0JBQ2xELE1BQU0sSUFBSSxlQUFHLFNBQVMsQ0FBQyxZQUFZLDBDQUFFLElBQUksbUNBQUksMkJBQVksQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDO2dCQUN0RSxnSUFBZ0k7Z0JBQ2hJLGlFQUFpRTtnQkFDakUsTUFBTSxhQUFh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R0FBRyxFQUFFLENBQUM7S0FDeEI7SUFFRCxtSEFBbUg7SUFDbkgsSUFBSSxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLE9BQU8sQ0FBQyxFQUFFO1FBQzFDLDBFQUEwRTtRQUMxRSx3Q0FBd0M7UUFDeEMsTUFBTSxHQUFHLEdBQUcsSUFBSSxpQkFBVSxDQUFDLFVBQVUsRUFBRSxPQUFPLEVBQUUsRUFBRSxPQUFPLEVBQUUsSUFBSSxFQUFFLElBQUksRUFBRSxDQUFDLENBQUM7UUFDekUsT0FBTyxHQUFHLENBQUMsU0FBUyxDQUFDLFVBQUcsQ0FBQyxNQUFNLEVBQUUsS0FBSyxDQUFDLENBQUM7S0FDekM7SUFDRCwyRUFBMkU7SUFDM0UsT0FBTyxTQUFFLENBQUMsU0FBUyxDQUFDLE9BQU8sRUFBRSxVQUFHLENBQUMsTUFBTSxFQUFFLEtBQUssQ0FBQyxDQUFDO0FBQ2xELENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBBd3MsIENmbk1hcHBpbmcsIEZuLCBJUmVzb2x2ZUNvbnRleHQsIExhenksIFN0YWNrLCBUb2tlbiB9IGZyb20gJ0Bhd3MtY2RrL2NvcmUnO1xuaW1wb3J0IHsgRmFjdE5hbWUsIFJlZ2lvbkluZm8gfSBmcm9tICdAYXdzLWNkay9yZWdpb24taW5mbyc7XG5pbXBvcnQgeyBDb25zdHJ1Y3QgfSBmcm9tICdjb25zdHJ1Y3RzJztcbmltcG9ydCB7IEFyY2hpdGVjdHVyZSB9IGZyb20gJy4vYXJjaGl0ZWN0dXJlJztcbmltcG9ydCB7IElGdW5jdGlvbiB9IGZyb20gJy4vZnVuY3Rpb24tYmFzZSc7XG5cblxuLy8gVGhpcyBpcyB0aGUgbmFtZSBvZiB0aGUgbWFwcGluZyB0aGF0IHdpbGwgYmUgYWRkZWQgdG8gdGhlIENsb3VkRm9ybWF0aW9uIHRlbXBsYXRlLCBpZiBhIHN0YWNrIGlzIHJlZ2lvbiBhZ25vc3RpY1xuY29uc3QgREVGQVVMVF9NQVBQSU5HX1BSRUZJWCA9ICdMYW1iZGFJbnNpZ2h0c1ZlcnNpb25zJztcblxuLyoqXG4gKiBDb25maWcgcmV0dXJuZWQgZnJvbSB7QGxpbmsgTGFtYmRhSW5zaWdodHNWZXJzaW9uLl9iaW5kfVxuICovXG5pbnRlcmZhY2UgSW5zaWdodHNCaW5kQ29uZmlnIHtcbiAgLyoqXG4gICAqIEFSTiBvZiB0aGUgTGFtYmRhIEluc2lnaHRzIExheWVyIFZlcnNpb25cbiAgICovXG4gIHJlYWRvbmx5IGFybjogc3RyaW5nO1xufVxuXG4vLyBUbyBhZGQgbmV3IHZlcnNpb25zLCB1cGRhdGUgZmFjdC10YWJsZXMudHMgYENMT1VEV0FUQ0hfTEFNQkRBX0lOU0lHSFRTX0FSTlNgIGFuZCBjcmVhdGUgYSBuZXcgYHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgVkVSU0lPTl9BX0JfQ19EYFxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBMYW1iZGFJbnNpZ2h0c1ZlcnNpb24ge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgcHVibGljIHN0YXRpYyByZWFkb25seSBWRVJTSU9OXzFfMF81NF8wID0gTGFtYmRhSW5zaWdodHNWZXJzaW9uLmZyb21JbnNpZ2h0c1ZlcnNpb24oJzEuMC41NC4wJyk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IFZFUlNJT05fMV8wXzg2XzAgPSBMYW1iZGFJbnNpZ2h0c1ZlcnNpb24uZnJvbUluc2lnaHRzVmVyc2lvbignMS4wLjg2LjAnKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgVkVSU0lPTl8xXzBfODlfMCA9IExhbWJkYUluc2lnaHRzVmVyc2lvbi5mcm9tSW5zaWdodHNWZXJzaW9uKCcxLjAuODkuMCcpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgcHVibGljIHN0YXRpYyByZWFkb25seSBWRVJTSU9OXzFfMF85OF8wID0gTGFtYmRhSW5zaWdodHNWZXJzaW9uLmZyb21JbnNpZ2h0c1ZlcnNpb24oJzEuMC45OC4wJyk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgcHVibGljIHN0YXRpYyByZWFkb25seSBWRVJTSU9OXzFfMF8xMTlfMCA9IExhbWJkYUluc2lnaHRzVmVyc2lvbi5mcm9tSW5zaWdodHNWZXJzaW9uKCcxLjAuMTE5LjAnKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgcHVibGljIHN0YXRpYyBmcm9tSW5zaWdodFZlcnNpb25Bcm4oYXJuOiBzdHJpbmcpOiBMYW1iZGFJbnNpZ2h0c1ZlcnNpb24ge1xuICAgIGNsYXNzIEluc2lnaHRzQXJuIGV4dGVuZHMgTGFtYmRhSW5zaWdodHNWZXJzaW9uIHtcbiAgICAgIHB1YmxpYyByZWFkb25seSBsYXllclZlcnNpb25Bcm4gPSBhcm47XG4gICAgICBwdWJsaWMgX2JpbmQoX3Njb3BlOiBDb25zdHJ1Y3QsIF9mdW5jdGlvbjogSUZ1bmN0aW9uKTogSW5zaWdodHNCaW5kQ29uZmlnIHtcbiAgICAgICAgcmV0dXJuIHsgYXJuIH07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuZXcgSW5zaWdodHNBcm4oKTtcbiAgfVxuXG4gIC8vIFVzZSB0aGUgdmVyaXNvbiB0byBidWlsZCB0aGUgb2JqZWN0LiBOb3QgbWVhbnQgdG8gYmUgY2FsbGVkIGJ5IHRoZSB1c2VyIC0tIHVzZXIgc2hvdWxkIHVzZSBlLmcuIFZFUlNJT05fMV8wXzU0XzBcbiAgcHJpdmF0ZSBzdGF0aWMgZnJvbUluc2lnaHRzVmVyc2lvbihpbnNpZ2h0c1ZlcnNpb246IHN0cmluZyk6IExhbWJkYUluc2lnaHRzVmVyc2lvbiB7XG5cbiAgICBjbGFzcyBJbnNpZ2h0c1ZlcnNpb24gZXh0ZW5kcyBMYW1iZGFJbnNpZ2h0c1ZlcnNpb24ge1xuICAgICAgcHVibGljIHJlYWRvbmx5IGxheWVyVmVyc2lvbkFybiA9IExhenkudW5jYWNoZWRTdHJpbmcoe1xuICAgICAgICBwcm9kdWNlOiAoY29udGV4dCkgPT4gZ2V0VmVyc2lvbkFybihjb250ZXh0LCBpbnNpZ2h0c1ZlcnNpb24pLFxuICAgICAgfSk7XG5cbiAgICAgIHB1YmxpYyBfYmluZChfc2NvcGU6IENvbnN0cnVjdCwgX2Z1bmN0aW9uOiBJRnVuY3Rpb24pOiBJbnNpZ2h0c0JpbmRDb25maWcge1xuICAgICAgICBjb25zdCBhcmNoID0gX2Z1bmN0aW9uLmFyY2hpdGVjdHVyZT8ubmFtZSA/PyBBcmNoaXRlY3R1cmUuWDg2XzY0Lm5hbWU7XG4gICAgICAgIC8vIENoZWNrIGlmIGluc2lnaHRzIHZlcnNpb24gaXMgdmFsaWQuIFRoaXMgc2hvdWxkIG9ubHkgaGFwcGVuIGlmIG9uZSBvZiB0aGUgcHVibGljIHN0YXRpYyByZWFkb25seSB2ZXJzaW9ucyBhcmUgc2V0IGluY29ycmVjdGx5XG4gICAgICAgIC8vIG9yIGlmIHRoZSB2ZXJzaW9uIGlzIG5vdCBhdmFpbGFibGUgZm9yIHRoZSBMYW1iZGEgQXJjaGl0ZWN0dXJlXG4gICAgICAgIGNvbnN0IHZlcnNpb25FeGlzdHMgPSBSZWdpb25JbmZvLnJlZ2lvbnMuc29tZShyZWdpb25JbmZvID0+IHJlZ2lvbkluZm8uY2xvdWR3YXRjaExhbWJkYUluc2lnaHRzQXJuKGluc2lnaHRzVmVyc2lvbiwgYXJjaCkpO1xuICAgICAgICBpZiAoIXZlcnNpb25FeGlzdHMpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEluc2lnaHRzIHZlcnNpb24gJHtpbnNpZ2h0c1ZlcnNpb259IGRvZXMgbm90IGV4aXN0LmApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgYXJuOiBMYXp5LnVuY2FjaGVkU3RyaW5nKHtcbiAgICAgICAgICAgIHByb2R1Y2U6IChjb250ZXh0KSA9PiBnZXRWZXJzaW9uQXJuKGNvbnRleHQsIGluc2lnaHRzVmVyc2lvbiwgYXJjaCksXG4gICAgICAgICAgfSksXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuZXcgSW5zaWdodHNWZXJzaW9uKCk7XG4gIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gIHB1YmxpYyByZWFkb25seSBsYXllclZlcnNpb25Bcm46IHN0cmluZyA9ICcnO1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBhcm4gb2YgdGhlIExhbWJkYSBJbnNpZ2h0cyBleHRlbnNpb24gYmFzZWQgb24gdGhlXG4gICAqIExhbWJkYSBhcmNoaXRlY3R1cmVcbiAgICogQGludGVybmFsXG4gICAqL1xuICBwdWJsaWMgYWJzdHJhY3QgX2JpbmQoX3Njb3BlOiBDb25zdHJ1Y3QsIF9mdW5jdGlvbjogSUZ1bmN0aW9uKTogSW5zaWdodHNCaW5kQ29uZmlnO1xufVxuXG4vKipcbiAqIEZ1bmN0aW9uIHRvIHJldHJpZXZlIHRoZSBjb3JyZWN0IExhbWJkYSBJbnNpZ2h0cyBBUk4gZnJvbSBSZWdpb25JbmZvLFxuICogb3IgY3JlYXRlIGEgbWFwcGluZyB0byBsb29rIGl0IHVwIGF0IHN0YWNrIGRlcGxveW1lbnQgdGltZS5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIHJ1biBvbiBDREsgc3ludGhlc2lzLlxuICovXG5mdW5jdGlvbiBnZXRWZXJzaW9uQXJuKGNvbnRleHQ6IElSZXNvbHZlQ29udGV4dCwgaW5zaWdodHNWZXJzaW9uOiBzdHJpbmcsIGFyY2hpdGVjdHVyZT86IHN0cmluZyk6IHN0cmluZyB7XG5cbiAgY29uc3Qgc2NvcGVTdGFjayA9IFN0YWNrLm9mKGNvbnRleHQuc2NvcGUpO1xuICBjb25zdCByZWdpb24gPSBzY29wZVN0YWNrLnJlZ2lvbjtcbiAgY29uc3QgYXJjaCA9IGFyY2hpdGVjdHVyZSA/PyBBcmNoaXRlY3R1cmUuWDg2XzY0Lm5hbWU7XG5cbiAgLy8gUmVnaW9uIGlzIGRlZmluZWQsIGxvb2sgdXAgdGhlIGFybiwgb3IgdGhyb3cgYW4gZXJyb3IgaWYgdGhlIHZlcnNpb24gaXNuJ3Qgc3VwcG9ydGVkIGJ5IGEgcmVnaW9uXG4gIGlmIChyZWdpb24gIT09IHVuZGVmaW5lZCAmJiAhVG9rZW4uaXNVbnJlc29sdmVkKHJlZ2lvbikpIHtcbiAgICBjb25zdCBhcm4gPSBSZWdpb25JbmZvLmdldChyZWdpb24pLmNsb3Vkd2F0Y2hMYW1iZGFJbnNpZ2h0c0FybihpbnNpZ2h0c1ZlcnNpb24sIGFyY2gpO1xuICAgIGlmIChhcm4gPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnNpZ2h0cyB2ZXJzaW9uICR7aW5zaWdodHNWZXJzaW9ufSBpcyBub3Qgc3VwcG9ydGVkIGluIHJlZ2lvbiAke3JlZ2lvbn1gKTtcbiAgICB9XG4gICAgcmV0dXJuIGFybjtcbiAgfVxuXG4gIC8vIE90aGVyd2lzZSwgbmVlZCB0byBhZGQgYSBtYXBwaW5nIHRvIGJlIGxvb2tlZCB1cCBhdCBkZXBsb3ltZW50IHRpbWVcblxuICAvKipcbiAgICogU2VlIHRoaXMgZm9yIHRoZSBjb250ZXh0IGFzIHRvIHdoeSB0aGUgbWFwcGluZ3MgYXJlIHRoZSB3YXkgdGhleSBhcmVcbiAgICogaHR0cHM6Ly9kb2NzLmF3cy5hbWF6b24uY29tL0FXU0Nsb3VkRm9ybWF0aW9uL2xhdGVzdC9Vc2VyR3VpZGUvbWFwcGluZ3Mtc2VjdGlvbi1zdHJ1Y3R1cmUuaHRtbFxuICAgKlxuICAgKiBNYXBwaW5ncyBoYXZlIHRvIGhhdmUgYSBzdHJ1Y3R1cmUgbGlrZSB0aGlzLCBhbmQgbm8gZnVuY3Rpb25zIGNhbiBiZSB1c2VkIGluc2lkZSB0aGVtOlxuICAgKiA8QWxwaGFudW1lcmljIG9ubHk+XG4gICAqIC0gPENhbiBiZSBub24tYWxwaGFudW1lcmljPlxuICAgKiAtLSB7IDxhbHBoYW51bWVyaWM+OiBcInZhbHVlMVwifSxcbiAgICogLS0geyA8YWxwaGFudW1lcmljPjogXCJ2YWx1ZTJcIn1cbiAgICpcbiAgICogU28gd2UgY2Fubm90IGhhdmUgYW4gb3RoZXJ3aXNlIGlkZWFsIG1hcHBpbmcgbGlrZSB0aGlzLCBiZWNhdXNlICcxLjAuOTguMCcgaXMgbm9uLWFscGhhbnVtZXJpYzpcbiAgICogTGFtYmRhSW5zaWdodHNWZXJzaW9uc1xuICAgKiAtIHVzLWVhc3QtMVxuICAgKiAtLSB7JzEuMC45OC4wJzogJ2FybjEnfSxcbiAgICogLS0geycxLjAuODkuMCc6ICdhcm4yJ31cbiAgICpcbiAgICogVG8gZ2V0IGFyb3VuZCB0aGlzIGxpbWl0YXRpb24sIHRoaXMgaXMgdGhlIG1hcHBpbmcgc3RydWN0dXJlOlxuICAgKiBMYW1iZGFJbnNpZ2h0c1ZlcnNpb25zMTA5ODAgLy8gZm9yIHZlcnNpb24gMS4wLjk4LjBcbiAgICogLSB1cy1lYXN0LTFcbiAgICogLS0geydhcm4nOiAnYXJuMSd9LFxuICAgKiAtIHVzLWVhc3QtMlxuICAgKiAtLSB7J2Fybic6ICdhcm4yJ31cbiAgICogTGFtYmRhSW5zaWdodHNWZXJzaW9uczEwODkwIC8vIGEgc2VwYXJhdGUgbWFwcGluZyB2ZXJzaW9uIDEuMC44OS4wXG4gICAqIC0gdXMtZWFzdC0xXG4gICAqIC0tIHsnYXJuJzogJ2FybjMnfSxcbiAgICogLSB1cy1lYXN0LTJcbiAgICogLS0geydhcm4nOiAnYXJuNCd9XG4gICAqIExhbWJkYUluc2lnaHRzVmVyc2lvbnMxMDExOTBhcm02NCAvLyBhIHNlcGFyYXRlIG1hcHBpbmcgdmVyc2lvbiAxLjAuMTE5LjAgYXJtNjRcbiAgICogLSB1cy1lYXN0LTFcbiAgICogLS0geydhcm4nOiAnYXJuMyd9LFxuICAgKiAtIHVzLWVhc3QtMlxuICAgKiAtLSB7J2Fybic6ICdhcm40J31cbiAgICovXG5cbiAgbGV0IG1hcE5hbWUgPSBERUZBVUxUX01BUFBJTkdfUFJFRklYICsgaW5zaWdodHNWZXJzaW9uLnNwbGl0KCcuJykuam9pbignJyk7XG4gIC8vIGlmIHRoZSBhcmNoaXRlY3R1cmUgaXMgYXJtNjQgdGhlbiBhcHBlbmQgdGhhdCB0byB0aGUgZW5kIG9mIHRoZSBuYW1lXG4gIC8vIHRoaXMgaXMgc28gdGhhdCB3ZSBjYW4gaGF2ZSBhIHNlcGFyYXRlIG1hcHBpbmcgZm9yIHg4NiB2cyBhcm0gaW4gc2NlbmFyaW9zXG4gIC8vIHdoZXJlIHdlIGhhdmUgTGFtYmRhIGZ1bmN0aW9ucyB3aXRoIGJvdGggYXJjaGl0ZWN0dXJlcyBpbiB0aGUgc2FtZSBzdGFja1xuICBpZiAoYXJjaCA9PT0gQXJjaGl0ZWN0dXJlLkFSTV82NC5uYW1lKSB7XG4gICAgbWFwTmFtZSArPSBhcmNoO1xuICB9XG4gIGNvbnN0IG1hcHBpbmc6IHsgW2sxOiBzdHJpbmddOiB7IFtrMjogc3RyaW5nXTogYW55IH0gfSA9IHt9O1xuICBjb25zdCByZWdpb24yYXJucyA9IFJlZ2lvbkluZm8ucmVnaW9uTWFwKEZhY3ROYW1lLmNsb3Vkd2F0Y2hMYW1iZGFJbnNpZ2h0c1ZlcnNpb24oaW5zaWdodHNWZXJzaW9uLCBhcmNoKSk7XG4gIGZvciAoY29uc3QgW3JlZywgYXJuXSBvZiBPYmplY3QuZW50cmllcyhyZWdpb24yYXJucykpIHtcbiAgICBtYXBwaW5nW3JlZ10gPSB7IGFybiB9O1xuICB9XG5cbiAgLy8gT25seSBjcmVhdGUgYSBnaXZlbiBtYXBwaW5nIG9uY2UuIElmIGFub3RoZXIgdmVyc2lvbiBvZiBpbnNpZ2h0cyBpcyB1c2VkIGVsc2V3aGVyZSwgdGhhdCBtYXBwaW5nIHdpbGwgYWxzbyBleGlzdFxuICBpZiAoIXNjb3BlU3RhY2subm9kZS50cnlGaW5kQ2hpbGQobWFwTmFtZSkpIHtcbiAgICAvLyBuZWVkIHRvIGNhbGwgZmluZEluTWFwIGhlcmUgaWYgd2UgYXJlIGdvaW5nIHRvIHNldCBsYXp5PXRydWUsIG90aGVyd2lzZVxuICAgIC8vIHdlIGdldCB0aGUgaW5mb3JtTGF6eVVzZSBpbmZvIG1lc3NhZ2VcbiAgICBjb25zdCBtYXAgPSBuZXcgQ2ZuTWFwcGluZyhzY29wZVN0YWNrLCBtYXBOYW1lLCB7IG1hcHBpbmcsIGxhenk6IHRydWUgfSk7XG4gICAgcmV0dXJuIG1hcC5maW5kSW5NYXAoQXdzLlJFR0lPTiwgJ2FybicpO1xuICB9XG4gIC8vIFRoZSBBUk4gd2lsbCBiZSBsb29rZWQgdXAgYXQgZGVwbG95bWVudCB0aW1lIGZyb20gdGhlIG1hcHBpbmcgd2UgY3JlYXRlZFxuICByZXR1cm4gRm4uZmluZEluTWFwKG1hcE5hbWUsIEF3cy5SRUdJT04sICdhcm4nKTtcbn1cbiJdfQ==